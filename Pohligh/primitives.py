"""Contains some basic mathematical functions used in the Pohlig-Hellman algorithm."""
import functools
import typing
import itertools
import egcd

def orderFactors(g: int, p: int, phiFactorization: typing.List[typing.Tuple[int,int]])->typing.Iterable[typing.Tuple[int,int]]:
    """Find the order of the cyclic subgroup generated by g in the multiplicative group formed by the integers coprime to p.

    Args:
        g: the generator of the desired subgroup.
        p: The modulus that defines the larger multiplicative group that contains g.
        phiFactorization: The precomputed factorization of totient(p) in the format [(p, e)] where the product of all p**e = totient(p).
    
    Returns:
        A generator object that finds the prime factors of the order of the subgroup generated by g one by one, in the same format as the phi factorization parameter.
    """
    phi = functools.reduce(lambda x, y: x * y[0]**y[1],itertools.chain([1],phiFactorization))
    for prime, exp in phiFactorization:
        for i in range(1,exp+1):
            if pow(g,phi//(prime**i),p) != 1:
                #If pow(g,phi//(prime**i),p) != 1, we know prime**i | ord(<g>)
                yield (prime,exp-i+1)
                break

def order(g: int, p: int, phiFactorization: typing.List[typing.Tuple[int,int]])->int:
    """Calculates the order of a cyclic subgroup generated by g in the multiplicative group in the integers mod p.
    
    Args:
        g: The generator of the desired subgroup.
        p: The modulus that defines the larger multiplicative group that contains g.
        phiFactorization: The precomputed factorization of totient(p) in the format [(p, e)] where the product of all p**e = totient(p).

    Returns:
        The order of the subgroup generated by g in the multiplicative group defined by p.
    """
    return functools.reduce(lambda x, y: x*y[0]**y[1],itertools.chain([1],orderFactors(g,p,phiFactorization)))

def CRT(*args: typing.List[typing.Tuple[int,int]])->int:
    """Calculates x where x is congruent to T[0] mod T[1] for each tuple T supplied. Assumes all values of T[1] are coprime.
    
    Args:
        Tuples in the form (a, n) where the result will be congruent to a mod n for all a and n.
    
    Returns:
        I've told you twice already; pay attention.
    """
    def _CRT_Pair(a1,n1,a2,n2):
        m1, m2 = egcd.egcd(n1,n2)[1:]
        return (a1*m2*n2 + a2*m1*n1) % (n1*n2), n1*n2
    return functools.reduce(lambda t1, t2: _CRT_Pair(*t1,*t2),args)[0]

def inverse(x: int,modulus: int)->int:
    """Finds the multiplicative inverse of x mod modulus; that is, the number x^-1 where x * x^-1 = 1 mod modulus.
    
    Args:
        x: the number to take the inverse of.
        modulus: the modulus the inverse is being taken over.
    
    Returns;
        The inverse of x mod modulus.
    """
    a, n1 = egcd.egcd(x,modulus)[:2]
    if a != 1:
        raise ValueError(f"{x} is not coprime to {modulus}!")
    return n1